//#include <stdio.h>
#include <opencv2/bgsegm.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/video/background_segm.hpp>
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;


// this creates an object for the current fram and the masks we are using to isolate the image
Mat frame; //current frame
Mat fgMaskMOG; //fg mask generated by MOG method <-- figure out what this means
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method <-- ditto.


Ptr<BackgroundSubtractor> pMOG; //pMog Background subtractor
Ptr<BackgroundSubtractor> pMOG2; 

int keyboard;


void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);


int main(int argc,char** argv)
{
	if(argc != 3)
	{
		cerr <<"Incorrect input list"<< endl;
		cerr <<"exiting..." << endl;
		return EXIT_FAILURE;
	}
	
	//create GUI windows
	namedWindow("Frame");
	namedWindow("FG Mask MOG");
	namedWindow("FG MASK MOG 2");
	
	//create Background Subtractor objects
	
	
	//pMOG = createBackgroundSubtractorMOG(); //MOG approach
	pMOG = bgsegm::createBackgroundSubtractorMOG();
	
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	
	
	
	//takes the input sees if it can be processed as images or video
	//if it cannot return an error and closes
	if(strcmp(argv[1], "-vid") == 0) 
	{
	//input data coming from a video
    processVideo(argv[2]);
	}
	else if(strcmp(argv[1], "-img") == 0) 
	{
		//input data coming from a sequence of images
		processImages(argv[2]);
	}
	else 
	{
		//error in reading input parameters
		cerr <<"Please, check the input parameters." << endl;
		cerr <<"Exiting..." << endl;
		return EXIT_FAILURE;
	}
	
	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;
}

void processVideo(char* videoFilename)
{
	// creat video caputre object 
	VideoCapture capture(videoFilename);
	
	//error check
	if(!capture.isOpened())
	{
		//error from opening
		cerr << "unable to open video file: "<<videoFilename<<endl;
		exit(EXIT_FAILURE);
	}
	
	// read input data. ESC or 'q' for quitting
	//done in while loop to continue
	while( (char)keyboard != 'q' && (char)keyboard != 27 ) //keyboard = 27 means esc was presses
	{
		  //error check
		if(!capture.read(frame))
		{
			cerr << "Unable to read next fram.:" <<endl;
			cerr << "Exiting..." <<endl;
			exit(EXIT_FAILURE);
		}

		//update background model
		pMOG -> apply(frame, fgMaskMOG);
		pMOG2 -> apply(frame, fgMaskMOG2);
		
		//get frame number and write on current frams
		stringstream ss;
		rectangle(frame, cv::Point(10,2), cv::Point(100,20), cv::Scalar(255,255,255),-1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		
		String frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15,15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
		
		
		//show the current frame and the fg masks
		//imshow creates a window to chow an iamge
		imshow("Frame", frame);
		imshow("FG Mask MOG", fgMaskMOG);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		//get the input from the keyboard
		keyboard = waitKey( 30 );
	}
						
	//delete capture object
	capture.release();
		
  }
  
  
 void processImages(char* fistFrameFilename)  
 {
	//read the first file of the sequence
	frame = imread(fistFrameFilename);
	
	if(!frame.data)
	{
		//error in opening the first image
		cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
		exit(EXIT_FAILURE);
	}
	//current image filename
	string fn(fistFrameFilename);
	//read input data. ESC or 'q' for quitting
  
	while( (char)keyboard != 'q' && (char)keyboard != 27 )
	{
    //update the background model
    pMOG->apply(frame, fgMaskMOG);
    pMOG2->apply(frame, fgMaskMOG2);
   
    //get the frame number and write it on the current frame
    size_t index = fn.find_last_of("/");
   
    if(index == string::npos) 
    {
      index = fn.find_last_of("\\");
    }
    
    size_t index2 = fn.find_last_of(".");
    string prefix = fn.substr(0,index+1);
    string suffix = fn.substr(index2);
    string frameNumberString = fn.substr(index+1, index2-index-1);
    istringstream iss(frameNumberString);
    int frameNumber = 0;
    iss >> frameNumber;
    
    rectangle(frame, cv::Point(10, 2), cv::Point(100,20), cv::Scalar(255,255,255), -1);
    putText(frame, frameNumberString.c_str(), cv::Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5 , cv::Scalar(0,0,0));
    
    //show the current frame and the fg masks
    imshow("Frame", frame);
    imshow("FG Mask MOG", fgMaskMOG);
    imshow("FG Mask MOG 2", fgMaskMOG2);
    
    //get the input from the keyboard
    keyboard = waitKey( 30 );
    
    //search for the next image in the sequence
    ostringstream oss;
    oss << (frameNumber + 1);
    string nextFrameNumberString = oss.str();
    string nextFrameFilename = prefix + nextFrameNumberString + suffix;
    
    //read the next frame
    frame = imread(nextFrameFilename);
    
    
    if(!frame.data)
    {
      //error in opening the next image in the sequence
      cerr << "Unable to open image frame: " << nextFrameFilename << endl;
      exit(EXIT_FAILURE);
    }
    
    
    //update the path of the current frame
    fn.assign(nextFrameFilename);
  }
}	
